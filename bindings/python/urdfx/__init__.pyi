import numpy as np
from typing import List, Optional, Tuple, ClassVar
from enum import Enum

__version__: str

class JointType(Enum):
    Fixed: int
    Revolute: int
    Continuous: int
    Prismatic: int
    Floating: int
    Planar: int

class GeometryType(Enum):
    Box: int
    Cylinder: int
    Sphere: int
    Mesh: int

class JacobianType(Enum):
    Analytic: int
    Geometric: int

class Transform:
    def __init__(self, t: Optional[np.ndarray] = None) -> None: ...
    @staticmethod
    def from_position_quaternion(position: np.ndarray, quaternion: np.ndarray) -> Transform: ...
    @staticmethod
    def from_position_rpy(position: np.ndarray, rpy: np.ndarray) -> Transform: ...
    def inverse(self) -> Transform: ...
    def translation(self) -> np.ndarray: ...
    def rotation(self) -> np.ndarray: ...
    def as_matrix(self) -> np.ndarray: ...
    def as_position_quaternion(self) -> Tuple[np.ndarray, np.ndarray]: ...
    def as_position_rpy(self) -> Tuple[np.ndarray, np.ndarray]: ...
    def __mul__(self, other: Transform) -> Transform: ...

class JointLimits:
    lower: float
    upper: float
    effort: float
    velocity: float
    def __init__(self) -> None: ...

class JointDynamics:
    damping: float
    friction: float
    def __init__(self) -> None: ...

class Geometry:
    type: GeometryType
    box_size: np.ndarray
    cylinder_radius: float
    cylinder_length: float
    sphere_radius: float
    mesh_filename: str
    mesh_scale: np.ndarray
    def __init__(self) -> None: ...

class Visual:
    name: str
    origin: Transform
    geometry: Geometry
    color: Optional[np.ndarray]
    material_name: Optional[str]
    def __init__(self) -> None: ...

class Collision:
    name: str
    origin: Transform
    geometry: Geometry
    def __init__(self) -> None: ...

class Inertial:
    origin: Transform
    mass: float
    inertia: np.ndarray
    def __init__(self) -> None: ...

class Link:
    def __init__(self, name: str) -> None: ...
    def get_name(self) -> str: ...
    def get_inertial(self) -> Optional[Inertial]: ...
    def set_inertial(self, inertial: Inertial) -> None: ...
    def get_visuals(self) -> List[Visual]: ...
    def add_visual(self, visual: Visual) -> None: ...
    def get_collisions(self) -> List[Collision]: ...
    def add_collision(self, collision: Collision) -> None: ...

class Joint:
    def __init__(self, name: str, type: JointType) -> None: ...
    def get_name(self) -> str: ...
    def get_type(self) -> JointType: ...
    def get_parent_link(self) -> str: ...
    def set_parent_link(self, parent: str) -> None: ...
    def get_child_link(self) -> str: ...
    def set_child_link(self, child: str) -> None: ...
    def get_origin(self) -> Transform: ...
    def set_origin(self, origin: Transform) -> None: ...
    def get_axis(self) -> np.ndarray: ...
    def set_axis(self, axis: np.ndarray) -> None: ...
    def get_limits(self) -> Optional[JointLimits]: ...
    def set_limits(self, limits: JointLimits) -> None: ...
    def get_dynamics(self) -> Optional[JointDynamics]: ...
    def set_dynamics(self, dynamics: JointDynamics) -> None: ...
    def is_actuated(self) -> bool: ...
    def get_transform(self, value: float) -> Transform: ...

class Robot:
    dof: int
    def __init__(self, name: str) -> None: ...
    def get_name(self) -> str: ...
    def get_root_link(self) -> str: ...
    def set_root_link(self, root: str) -> None: ...
    def add_link(self, link: Link) -> None: ...
    def get_link(self, name: str) -> Optional[Link]: ...
    def get_links(self) -> List[Link]: ...
    def add_joint(self, joint: Joint) -> None: ...
    def get_joint(self, name: str) -> Optional[Joint]: ...
    def get_joints(self) -> List[Joint]: ...
    def get_actuated_joints(self) -> List[Joint]: ...
    def get_child_joints(self, link_name: str) -> List[Joint]: ...
    def get_parent_joint(self, link_name: str) -> Optional[Joint]: ...
    def validate(self) -> bool: ...
    def get_joint_names(self) -> List[str]: ...
    def get_joint_limits(self) -> np.ndarray: ...
    @staticmethod
    def from_urdf_file(path: str) -> Robot: ...
    @staticmethod
    def from_urdf_string(xml: str) -> Robot: ...

class URDFParser:
    base_directory: str
    def __init__(self) -> None: ...
    def parse_file(self, filepath: str) -> Robot: ...
    def parse_string(self, urdf_string: str) -> Robot: ...

class KinematicChain:
    def __init__(self, robot: Robot, end_link: str, base_link: str = "") -> None: ...
    def get_num_joints(self) -> int: ...
    def get_joints(self) -> List[Joint]: ...
    def get_link_names(self) -> List[str]: ...
    def get_end_link(self) -> str: ...
    def get_base_link(self) -> str: ...
    def get_static_transforms(self) -> List[Transform]: ...

class ForwardKinematics:
    num_joints: int
    def __init__(self, robot: Robot, end_link: str, base_link: str = "") -> None: ...
    def compute(self, joint_angles: np.ndarray, check_bounds: bool = False) -> Transform: ...
    def compute_to_link(self, joint_angles: np.ndarray, target_link: str, check_bounds: bool = False) -> Transform: ...
    def get_chain(self) -> KinematicChain: ...
    def get_num_joints(self) -> int: ...

class JacobianCalculator:
    def __init__(self, robot: Robot, end_link: str, base_link: str = "") -> None: ...
    def compute(self, joint_angles: np.ndarray, type: JacobianType = JacobianType.Analytic, target_link: str = "") -> np.ndarray: ...
    def compute_jacobian_derivative(self, joint_angles: np.ndarray, joint_velocities: np.ndarray, type: JacobianType = JacobianType.Analytic, target_link: str = "") -> np.ndarray: ...
    def is_singular(self, joint_angles: np.ndarray, threshold: float = 1e-6, type: JacobianType = JacobianType.Analytic, target_link: str = "") -> bool: ...
    def get_manipulability(self, joint_angles: np.ndarray, type: JacobianType = JacobianType.Analytic, target_link: str = "") -> float: ...
    def get_condition_number(self, joint_angles: np.ndarray, type: JacobianType = JacobianType.Analytic, target_link: str = "") -> float: ...
    @staticmethod
    def convert_jacobian(jacobian: np.ndarray, pose: Transform, from_type: JacobianType, to_type: JacobianType) -> np.ndarray: ...

class SolverConfig:
    max_iterations: int
    tolerance: float
    regularization: float
    max_step_size: float
    max_line_search_steps: int
    line_search_shrink: float
    line_search_min_alpha: float
    line_search_improvement: float
    position_weight: float
    orientation_weight: float
    position_anchor_weight: float
    orientation_anchor_weight: float
    joint_limit_margin: float
    unbounded_joint_limit: float
    enable_warm_start: bool
    def __init__(self) -> None: ...

class SolverStatus:
    converged: bool
    iterations: int
    final_error_norm: float
    final_step_norm: float
    qp_status: int
    message: str
    error_history: List[float]
    def __init__(self) -> None: ...

class IKResult:
    status: SolverStatus
    solution: np.ndarray

class IKSolver:
    tolerance: float
    max_iterations: int
    def set_solver_config(self, config: SolverConfig) -> None: ...
    def get_solver_config(self) -> SolverConfig: ...
    def set_position_only(self, enable: bool) -> None: ...
    def set_orientation_only(self, enable: bool) -> None: ...
    def set_warm_start(self, guess: np.ndarray) -> None: ...

class SQPIKSolver(IKSolver):
    def __init__(self, robot: Robot, end_link: str, base_link: str = "") -> None: ...
    def solve(self, target_pose: Transform, initial_guess: np.ndarray) -> IKResult: ...

