import numpy as np
import urdfx
from .generator import MixedChainGenerator
from .oracle import FKOracle
import xml.etree.ElementTree as ET

def parse_urdf_simple(urdf_str):
    """
    Simple parser to extract joint axes and origins for verification.
    Assumes serial chain structure as generated by MixedChainGenerator.
    """
    root = ET.fromstring(urdf_str)
    joints = []
    
    # Map links to find chain order
    # Assuming linear chain: base_link -> link_1 -> link_2 ...
    
    # Find all joints
    joint_map = {}
    for joint in root.findall('joint'):
        name = joint.get('name')
        type_ = joint.get('type')
        parent = joint.find('parent').get('link')
        child = joint.find('child').get('link')
        
        origin = joint.find('origin')
        xyz = [float(x) for x in origin.get('xyz').split()]
        rpy = [float(x) for x in origin.get('rpy').split()]
        
        axis_elem = joint.find('axis')
        axis = [float(x) for x in axis_elem.get('xyz').split()] if axis_elem is not None else [1, 0, 0]
        
        joint_map[child] = {
            'name': name,
            'type': type_,
            'xyz': np.array(xyz),
            'rpy': np.array(rpy), # Simplified: assuming 0 for now as generator uses 0
            'axis': np.array(axis)
        }
        
    # Reconstruct chain
    ordered_joints = []
    current_link = "link_1"
    while current_link in joint_map:
        ordered_joints.append(joint_map[current_link])
        # Predict next link name
        idx = int(current_link.split('_')[1])
        current_link = f"link_{idx+1}"
        
    return ordered_joints

def rpy_to_matrix(rpy):
    # Simplified: generator uses 0 0 0
    return np.eye(3)

def compute_fk_python(joints, q):
    """
    Pure Python FK implementation.
    """
    T = np.eye(4)
    
    for i, joint in enumerate(joints):
        # Joint transform
        # 1. Static transform from parent link to joint frame
        T_static = np.eye(4)
        T_static[:3, 3] = joint['xyz']
        # Rotation from RPY (skipped as generator uses 0)
        
        # 2. Joint variable transform
        T_joint = np.eye(4)
        val = q[i]
        axis = joint['axis']
        
        if joint['type'] == 'revolute' or joint['type'] == 'continuous':
            # Axis-angle rotation
            # Rodrigues formula
            K = np.array([
                [0, -axis[2], axis[1]],
                [axis[2], 0, -axis[0]],
                [-axis[1], axis[0], 0]
            ])
            R = np.eye(3) + np.sin(val) * K + (1 - np.cos(val)) * (K @ K)
            T_joint[:3, :3] = R
        elif joint['type'] == 'prismatic':
            T_joint[:3, 3] = axis * val
            
        T = T @ T_static @ T_joint
        
    return T

def verify_oracle(dof=10, trials=100):
    print(f"Verifying FK Oracle for {dof}-DOF robot...")
    
    # 1. Generate Robot
    gen = MixedChainGenerator(dof=dof, seed=42)
    urdf_str = gen.to_urdf_string()
    
    # 2. Load into urdfx
    robot = urdfx.Robot.from_urdf_string(urdf_str)
    oracle = FKOracle(robot)
    
    # 3. Parse for Python verification
    joints = parse_urdf_simple(urdf_str)
    
    # 4. Test random configurations
    rng = np.random.RandomState(42)
    max_error = 0.0
    
    for _ in range(trials):
        q = rng.uniform(-1.0, 1.0, size=dof)
        
        # urdfx FK
        pos_urdfx, rot_urdfx = oracle.compute_pose(q)
        T_urdfx = np.eye(4)
        T_urdfx[:3, 3] = pos_urdfx
        T_urdfx[:3, :3] = rot_urdfx
        
        # Python FK
        T_py = compute_fk_python(joints, q)
        
        # Compare
        diff = np.abs(T_urdfx - T_py).max()
        max_error = max(max_error, diff)
        
    print(f"Max Error: {max_error}")
    if max_error < 1e-6:
        print("VERIFICATION PASSED")
        return True
    else:
        print("VERIFICATION FAILED")
        return False

if __name__ == "__main__":
    verify_oracle()
